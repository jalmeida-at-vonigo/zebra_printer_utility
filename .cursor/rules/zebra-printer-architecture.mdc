# Zebra Printer Plugin Architecture & Dependency Direction

_Last updated: 2024-12-20_

## 1. Overview
This plugin follows a **strict 3-layer architecture** with clear separation of responsibilities and dependency direction. All business and workflow logic is in Dart; native code is a thin bridge only.

## 2. Main API Entry Point

The primary entry point for Zebra printer operations is [zebra.dart](mdc:lib/zebra.dart), which provides a static API for all printer functionality.

## 3. Dependency Direction (Enforced)
- **ALWAYS:** `SmartPrintManager` → `ZebraPrinterManager` → `ZebraPrinter`
- **NEVER:** `ZebraPrinterManager` → `SmartPrintManager`
- **NEVER:** `ZebraPrinter` → any higher layer

### What this means:
- `ZebraPrinterManager` **must not import, reference, or depend on** `SmartPrintManager` in any way.
- `SmartPrintManager` is responsible for all workflow logic, event streams, retries, and orchestration.
- `ZebraPrinterManager` exposes only primitive operations, state management, and device/printer instance management.
- If a workflow manager is needed, it is created by the consumer (UI, static API, etc.), passing the manager as a dependency.
- This separation is **strictly enforced**. Any circular reference or import in the wrong direction is a violation.

## 4. Core Architecture Components

### 4.1 Static API Pattern
All operations are accessed through static methods on the `Zebra` class:
- **Discovery**: `Zebra.discoverPrinters()`, `Zebra.discoverPrintersStream()`
- **Connection**: `Zebra.connect()`, `Zebra.disconnect()`, `Zebra.isConnected()`
- **Printing**: `Zebra.print()`, `Zebra.smartPrint()`, `Zebra.cancelSmartPrint()`
- **Status**: `Zebra.getPrinterStatus()`, `Zebra.getDetailedPrinterStatus()`

### 4.2 Initialization Requirements
**CRITICAL**: All public API methods automatically call `_ensureInitialized()` to ensure proper setup:
- The `ZebraPrinterManager` is initialized on first use
- The `SmartPrintManager` is created lazily with proper initialization
- No manual initialization is required for normal usage

### 4.3 Manager Access Patterns
- **ZebraPrinterManager**: Access via `Zebra.manager` for advanced operations
- **SmartPrintManager**: Access via `Zebra.smartPrintManager` for smart print workflows
- **Discovery**: Access via `Zebra.discovery` for direct discovery control

## 5. File Responsibilities

### 5.1 ZebraPrinterManager ([lib/zebra_printer_manager.dart](mdc:lib/zebra_printer_manager.dart))
- **Responsibilities:**
  - Create/manage `ZebraPrinter` instances
  - Manage connection state, streams, and device discovery
  - Expose primitive operations: connect, disconnect, print (with data preparation), get/set settings, status
  - **No workflow logic, no event orchestration, no retry logic**
- **Must NOT:**
  - Import or reference `SmartPrintManager`
  - Expose any workflow/event API
  - Contain any business logic beyond data preparation for print

### 5.2 SmartPrintManager ([lib/smart_print_manager.dart](mdc:lib/smart_print_manager.dart))
- **Responsibilities:**
  - All workflow logic: retries, event streams, progress, error handling, orchestration
  - Consumes a `ZebraPrinterManager` instance (passed as a dependency)
  - Exposes event-driven API for UI and static API
- **Must NOT:**
  - Expose primitive operations directly (always use the manager)

### 5.3 ZebraPrinter ([lib/zebra_printer.dart](mdc:lib/zebra_printer.dart))
- **Responsibilities:**
  - Pure native wrapper for ZSDK operations
  - Only primitive, low-level operations
- **Must NOT:**
  - Contain any workflow, retry, or business logic

## 6. ZEBRA SGD COMMANDS - UTILITY ONLY

### Purpose
[ZebraSGDCommands](mdc:lib/zebra_sgd_commands.dart) should **ONLY** contain utility methods for:
- Data format detection
- Response parsing
- Language matching
- **NEVER command strings**

### Allowed Methods (Utility Only)
* `isZPLData(String data)` - Detect if data is ZPL format
* `isCPCLData(String data)` - Detect if data is CPCL format  
* `detectDataLanguage(String data)` - Determine print format from data
* `parseResponse(String response)` - Parse SGD response to extract value
* `isLanguageMatch(String current, String expected)` - Check language compatibility

### Forbidden Methods (Command Strings)
* `getCommand(String setting)` - ❌ Use CommandFactory instead
* `setCommand(String setting, String value)` - ❌ Use CommandFactory instead
* `doCommand(String action, String value)` - ❌ Use CommandFactory instead
* `setZPLMode()` - ❌ Use CommandFactory instead
* `setCPCLMode()` - ❌ Use CommandFactory instead
* `resetPrinter()` - ❌ Use CommandFactory instead
* `unpausePrinter()` - ❌ Use CommandFactory instead
* `resumePrinter()` - ❌ Use CommandFactory instead
* `clearAlerts()` - ❌ Use CommandFactory instead
* `cpclClearBuffer()` - ❌ Use CommandFactory instead
* `cpclFlushBuffer()` - ❌ Use CommandFactory instead
* `cpclClearErrors()` - ❌ Use CommandFactory instead
* `zplResume()` - ❌ Use CommandFactory instead
* `zplClearErrors()` - ❌ Use CommandFactory instead
* `zplClearBuffer()` - ❌ Use CommandFactory instead
* `zplFlushBuffer()` - ❌ Use CommandFactory instead

### Usage Examples

#### ✅ CORRECT - Utility Methods Only
```dart
// Data format detection
if (ZebraSGDCommands.isZPLData(data)) {
  // Handle ZPL data
}

// Language detection
final format = ZebraSGDCommands.detectDataLanguage(data);

// Response parsing
final value = ZebraSGDCommands.parseResponse(response);

// Language matching
if (ZebraSGDCommands.isLanguageMatch(currentLang, 'zpl')) {
  // Handle ZPL language
}
```

#### ❌ WRONG - Using for Commands
```dart
// ❌ DON'T DO THIS - Using ZebraSGDCommands for command strings
final command = ZebraSGDCommands.zplClearErrors();
_printer!.sendCommand(command);

// ❌ DON'T DO THIS - Using ZebraSGDCommands for SGD commands
final sgdCommand = ZebraSGDCommands.getCommand('device.languages');
_printer!.sendCommand(sgdCommand);

// ❌ DON'T DO THIS - Using ZebraSGDCommands for buffer operations
final bufferCommand = ZebraSGDCommands.cpclClearBuffer();
_printer!.sendCommand(bufferCommand);
```

## 7. Command Architecture

### CommandFactory Pattern
All command strings should be generated through the CommandFactory:
- **Location**: [lib/internal/commands/command_factory.dart](mdc:lib/internal/commands/command_factory.dart)
- **Usage**: `CommandFactory.createCommand(CommandType.commandName, parameters)`
- **Benefits**: Centralized command management, type safety, easy testing

### Command Classes
Individual command classes should be used for specific operations:
- **Base**: [lib/internal/commands/base_command.dart](mdc:lib/internal/commands/base_command.dart)
- **Examples**: `SendClearAlertsCommand`, `SendZplClearErrorsCommand`, etc.
- **Pattern**: Each command class handles one specific operation

## 8. API Usage Guidelines

### Simple Operations
```dart
// Discover and connect
final printers = await Zebra.discoverPrinters();
await Zebra.connect(printers.first.address);

// Simple print
await Zebra.print('^XA^FO50,50^FDHello^FS^XZ');

// Disconnect
await Zebra.disconnect();
```

### Advanced Operations
```dart
// Smart print with event monitoring
final eventStream = Zebra.smartPrint(
  '^XA^FO50,50^FDHello^FS^XZ',
  maxAttempts: 3,
  timeout: Duration(seconds: 60),
);

eventStream.listen((event) {
  // Handle print events
});
```

### Stream-Based Discovery
```dart
// Real-time discovery
final deviceStream = await Zebra.discoverPrintersStream(
  timeout: Duration(seconds: 10),
  stopOnFirstPrinter: true,
);

deviceStream.listen((devices) {
  // Handle discovered devices
});
```

## 9. Architecture Principles

### 9.1 Lazy Initialization
- Managers are created only when needed
- Initialization happens automatically on first API call
- No explicit initialization required

### 9.2 Static API Design
- All operations are static methods for simplicity
- Consistent error handling with `Result<T>` pattern
- Stream-based operations for real-time updates

### 9.3 Manager Delegation
- Simple operations delegate to appropriate managers
- Complex workflows use specialized managers
- Direct manager access available for advanced use cases

### 9.4 Error Handling
- All operations return `Result<T>` for consistent error handling
- Smart print provides detailed error classification
- Automatic retry logic in smart print operations

### 9.5 Command Separation
- **Utility methods** in ZebraSGDCommands for data processing
- **Command strings** generated through CommandFactory
- **Command execution** handled by command classes
- **Never mix** utility and command generation

## 10. Circular Dependency Warning
- **Any import or reference from `ZebraPrinterManager` to `SmartPrintManager` is strictly forbidden.**
- If you need workflow logic, create a new `SmartPrintManager` in the consumer (UI, static API, etc.) and pass the manager as a dependency.
- This ensures a clean, maintainable, and testable architecture.

## 11. Example Usage

### Correct: UI or static API creates workflow manager
```dart
// Correct: UI or static API creates workflow manager
final manager = ZebraPrinterManager();
final smart = SmartPrintManager(manager);
final events = await smart.smartPrint(...);
```

### Forbidden: ZebraPrinterManager importing or referencing SmartPrintManager
```dart
// Forbidden: ZebraPrinterManager importing or referencing SmartPrintManager
// (This will break the architecture and is not allowed)
```

## 12. Summary Table
| Layer                | File                        | Depends On                | Exposes                |
|----------------------|-----------------------------|---------------------------|------------------------|
| Workflow/Orchestration | smart_print_manager.dart   | ZebraPrinterManager       | Events, workflow API   |
| State/Primitives     | zebra_printer_manager.dart  | ZebraPrinter              | Primitive ops, state   |
| Native Wrapper       | zebra_printer.dart          | (none)                    | Native ops only        |

## 13. File Structure Reference

- **[zebra.dart](mdc:lib/zebra.dart)**: Main static API entry point
- **[zebra_printer_manager.dart](mdc:lib/zebra_printer_manager.dart)**: Core printer management
- **[smart_print_manager.dart](mdc:lib/smart_print_manager.dart)**: Advanced print workflows
- **[zebra_printer_discovery.dart](mdc:lib/zebra_printer_discovery.dart)**: Device discovery
- **[zebra_printer.dart](mdc:lib/zebra_printer.dart)**: Low-level printer operations
- **[zebra_sgd_commands.dart](mdc:lib/zebra_sgd_commands.dart)**: Utility methods only (NO commands)
- **[command_factory.dart](mdc:lib/internal/commands/command_factory.dart)**: Command string generation
- **[internal/commands/](mdc:lib/internal/commands/)**: Individual command classes

## 14. Best Practices

1. **Use Static API**: Prefer `Zebra.method()` over direct manager access
2. **Handle Results**: Always check `Result.success` before using data
3. **Use Smart Print**: Use `Zebra.smartPrint()` for production printing
4. **Monitor Events**: Listen to print event streams for real-time status
5. **Proper Cleanup**: Call `Zebra.dispose()` when done with the plugin
6. **Utility Only**: Use ZebraSGDCommands for data processing, not commands
7. **CommandFactory**: Generate all command strings through CommandFactory
8. **Command Classes**: Use specific command classes for operations
9. **Respect Dependencies**: Never violate the dependency direction rules
10. **Layer Separation**: Keep workflow logic separate from primitive operations

## 15. Common Patterns

### Connection Management
```dart
// Always check connection before printing
if (await Zebra.isConnected()) {
  await Zebra.print(data);
} else {
  await Zebra.connect(printerAddress);
  await Zebra.print(data);
}
```

### Error Handling
```dart
final result = await Zebra.connect(printerAddress);
if (result.success) {
  // Connection successful
} else {
  // Handle error: result.error?.message
}
```

### Stream Management
```dart
// Always cancel subscriptions
StreamSubscription? subscription;
subscription = Zebra.smartPrint(data).listen((event) {
  // Handle event
});

// Clean up
subscription?.cancel();
```

### Data Format Detection
```dart
// Use utility methods for format detection
if (ZebraSGDCommands.isZPLData(data)) {
  // Handle ZPL format
} else if (ZebraSGDCommands.isCPCLData(data)) {
  // Handle CPCL format
} else {
  // Handle unknown format
}
```

### Command Generation
```dart
// Use CommandFactory for command strings
final clearCommand = CommandFactory.createCommand(
  CommandType.sendClearAlerts,
  {},
);
await printer.sendCommand(clearCommand);
```

## 16. Enforcement
- **This rule is always applied.**
- **Any violation (circular reference, wrong dependency direction) must be fixed immediately.**
- **Review this rule after any significant codebase change.**

---

**See also:**
- [Command System Architecture](mdc:.cursor/rules/command-files.mdc)
- [Result-Based Architecture](mdc:.cursor/rules/result-based-architecture.mdc)
- [Event System](mdc:.cursor/rules/event-system.mdc)
- [Platform-Specific Rules](mdc:.cursor/rules/ios/)
