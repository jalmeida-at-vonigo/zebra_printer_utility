# Zebra Printer Plugin Architecture & Dependency Direction

_Last updated: 2024-12-20_

## 1. Overview
This plugin follows a **strict 3-layer architecture** with clear separation of responsibilities and dependency direction. All business and workflow logic is in Dart; native code is a thin bridge only.

## 2. Main API Entry Point

The primary entry point for Zebra printer operations is [zebra.dart](mdc:lib/zebra.dart), which provides a static API for all printer functionality.

## 3. Dependency Direction (Enforced)
- **ALWAYS:** `SmartPrintManager` → `ZebraPrinterManager` → `ZebraPrinter`
- **NEVER:** `ZebraPrinterManager` → `SmartPrintManager`
- **NEVER:** `ZebraPrinter` → any higher layer

### What this means:
- `ZebraPrinterManager` **must not import, reference, or depend on** `SmartPrintManager` in any way.
- `SmartPrintManager` is responsible for all workflow logic, event streams, retries, and orchestration.
- `ZebraPrinterManager` exposes only primitive operations, state management, and device/printer instance management.
- If a workflow manager is needed, it is created by the consumer (UI, static API, etc.), passing the manager as a dependency.
- This separation is **strictly enforced**. Any circular reference or import in the wrong direction is a violation.

## 4. Core Architecture Components

### 4.1 Static API Pattern
All operations are accessed through static methods on the `Zebra` class:
- **Discovery**: `Zebra.discoverPrinters()`, `Zebra.discoverPrintersStream()`
- **Connection**: `Zebra.connect()`, `Zebra.disconnect()`, `Zebra.isConnected()`
- **Printing**: `Zebra.print()`, `Zebra.smartPrint()`, `Zebra.cancelSmartPrint()`
- **Status**: `Zebra.getPrinterStatus()`, `Zebra.getDetailedPrinterStatus()`

### 4.2 Initialization Requirements
**CRITICAL**: All public API methods automatically call `_ensureInitialized()` to ensure proper setup:
- The `ZebraPrinterManager` is initialized on first use
- The `SmartPrintManager` is created lazily with proper initialization
- No manual initialization is required for normal usage

### 4.3 Manager Access Patterns
- **ZebraPrinterManager**: Access via `Zebra.manager` for advanced operations
- **SmartPrintManager**: Access via `Zebra.smartPrintManager` for smart print workflows
- **Discovery**: Access via `Zebra.discovery` for direct discovery control

## 5. File Responsibilities

### 5.1 ZebraPrinterManager ([lib/zebra_printer_manager.dart](mdc:lib/zebra_printer_manager.dart))
- **Responsibilities:**
  - Create/manage `ZebraPrinter` instances
  - Manage connection state, streams, and device discovery
  - Expose primitive operations: connect, disconnect, print (with data preparation), get/set settings, status
  - **No workflow logic, no event orchestration, no retry logic**
- **Must NOT:**
  - Import or reference `SmartPrintManager`
  - Expose any workflow/event API
  - Contain any business logic beyond data preparation for print

### 5.2 SmartPrintManager ([lib/smart_print_manager.dart](mdc:lib/smart_print_manager.dart))
- **Responsibilities:**
  - All workflow logic: retries, event streams, progress, error handling, orchestration
  - Consumes a `ZebraPrinterManager` instance (passed as a dependency)
  - Exposes event-driven API for UI and static API
- **Must NOT:**
  - Expose primitive operations directly (always use the manager)

### 5.3 ZebraPrinter ([lib/zebra_printer.dart](mdc:lib/zebra_printer.dart))
- **Responsibilities:**
  - Pure native wrapper for ZSDK operations
  - Only primitive, low-level operations
  - Forwards calls to native layer via method channels
- **Must NOT:**
  - Contain any workflow, retry, or business logic
- **See Also:**
  - [Native Layer Responsibility Standards](mdc:.cursor/rules/native-layer-responsibility.mdc) for native implementation guidelines

## 6. ZEBRA SGD COMMANDS - UTILITY ONLY

### Purpose
[ZebraSGDCommands](mdc:lib/zebra_sgd_commands.dart) should **ONLY** contain utility methods for:
- Data format detection
- Response parsing
- Language matching
- **NEVER command strings**

### Allowed Methods (Utility Only)
* `isZPLData(String data)` - Detect if data is ZPL format
* `isCPCLData(String data)` - Detect if data is CPCL format  
* `detectDataLanguage(String data)` - Determine print format from data
* `parseResponse(String response)` - Parse SGD response to extract value
* `isLanguageMatch(String current, String expected)` - Check language compatibility

### Forbidden Methods (Command Strings)
* `getCommand(String setting)` - ❌ Use CommandFactory instead
* `setCommand(String setting, String value)` - ❌ Use CommandFactory instead
* `doCommand(String action, String value)` - ❌ Use CommandFactory instead
* `setZPLMode()` - ❌ Use CommandFactory instead
* `setCPCLMode()` - ❌ Use CommandFactory instead
* `resetPrinter()` - ❌ Use CommandFactory instead
* `unpausePrinter()` - ❌ Use CommandFactory instead
* `resumePrinter()` - ❌ Use CommandFactory instead
* `clearAlerts()` - ❌ Use CommandFactory instead
* `cpclClearBuffer()` - ❌ Use CommandFactory instead
* `cpclFlushBuffer()` - ❌ Use CommandFactory instead
* `cpclClearErrors()` - ❌ Use CommandFactory instead
* `zplResume()` - ❌ Use CommandFactory instead
* `zplClearErrors()` - ❌ Use CommandFactory instead
* `zplClearBuffer()` - ❌ Use CommandFactory instead
* `zplFlushBuffer()` - ❌ Use CommandFactory instead

### Usage Examples

#### ✅ CORRECT - Utility Methods Only
```dart
// Data format detection
if (ZebraSGDCommands.isZPLData(data)) {
  // Handle ZPL data
}

// Language detection
final format = ZebraSGDCommands.detectDataLanguage(data);

// Response parsing
final value = ZebraSGDCommands.parseResponse(response);

// Language matching
if (ZebraSGDCommands.isLanguageMatch(currentLang, 'zpl')) {
  // Handle ZPL language
}
```

#### ❌ WRONG - Using for Commands
```dart
// ❌ DON'T DO THIS - Using ZebraSGDCommands for command strings
final command = ZebraSGDCommands.zplClearErrors();
_printer!.sendCommand(command);

// ❌ DON'T DO THIS - Using ZebraSGDCommands for SGD commands
final sgdCommand = ZebraSGDCommands.getCommand('device.languages');
_printer!.sendCommand(sgdCommand);

// ❌ DON'T DO THIS - Using ZebraSGDCommands for buffer operations
final bufferCommand = ZebraSGDCommands.cpclClearBuffer();
_printer!.sendCommand(bufferCommand);
```

## 7. Command Architecture

### CommandFactory Pattern
All command strings should be generated through the CommandFactory:
- **Location**: [lib/internal/commands/command_factory.dart](mdc:lib/internal/commands/command_factory.dart)
- **Usage**: `CommandFactory.createCommand(CommandType.commandName, parameters)`
- **Benefits**: Centralized command management, type safety, easy testing

### Command Classes
Individual command classes should be used for specific operations:
- **Base**: [lib/internal/commands/base_command.dart](mdc:lib/internal/commands/base_command.dart)
- **Examples**: `SendClearAlertsCommand`, `SendZplClearErrorsCommand`, etc.
- **Pattern**: Each command class handles one specific operation

## 8. Printer Readiness Architecture

### Overview
Printer readiness follows a **lazy caching pattern** with **single hardware read per property** and **just-enough communication** principles. The architecture ensures efficient hardware communication while providing comprehensive status checking and automatic correction capabilities.

### Core Components

#### PrinterReadiness ([lib/models/printer_readiness.dart](mdc:lib/models/printer_readiness.dart))
- **Purpose**: Lazy status caching with single hardware read per property
- **Pattern**: Properties are read only when first accessed and cached thereafter
- **Options Respect**: Only reads hardware for properties enabled in ReadinessOptions
- **Reset Capability**: Provides reset methods to force re-reading when needed

#### PrinterReadinessManager ([lib/zebra_printer_readiness_manager.dart](mdc:lib/zebra_printer_readiness_manager.dart))
- **Purpose**: Orchestrates readiness checks and automatic corrections
- **Pattern**: Uses cached values from PrinterReadiness, never makes duplicate hardware calls
- **Fix Logic**: Applies corrections based on options and format requirements
- **No Reset Operations**: Does not trigger re-reads after applying fixes

### Key Architectural Principles

#### 1. Single Hardware Read Per Property
```dart
// ✅ CORRECT - Read once, cache forever
final readiness = PrinterReadiness(printer: printer, options: options);
final hasMedia = await readiness.hasMedia; // Reads hardware once
final hasMediaAgain = await readiness.hasMedia; // Uses cached value

// ❌ WRONG - Multiple hardware reads
final command1 = CommandFactory.createGetMediaStatusCommand(printer);
final command2 = CommandFactory.createGetMediaStatusCommand(printer);
```

#### 2. Options-Driven Communication
```dart
// Only read what's requested
final options = ReadinessOptions(
  checkConnection: true,
  checkMedia: false, // Won't read media status
  checkHead: true,
);

final readiness = PrinterReadiness(printer: printer, options: options);
await readiness.isConnected; // Reads hardware
await readiness.hasMedia; // Returns null (not read)
await readiness.headClosed; // Reads hardware
```

#### 3. Manager Uses Cached Values
```dart
// ✅ CORRECT - Manager uses cached values
Future<void> _checkAndFixMedia(PrinterReadiness readiness) async {
  final hasMedia = await readiness.hasMedia; // Uses cached value
  if (hasMedia == false) {
    // Apply fix without re-reading
    await applyMediaFix();
  }
}

// ❌ WRONG - Manager makes duplicate hardware calls
Future<void> _checkAndFixMedia(PrinterReadiness readiness) async {
  final command = CommandFactory.createGetMediaStatusCommand(_printer);
  final result = await command.execute(); // Duplicate hardware call
}
```

#### 4. Fix Flags Allow Reading
```dart
// Fix flags implicitly allow reading the corresponding status
final options = ReadinessOptions(
  fixPausedPrinter: true, // Allows reading pause status
  fixPrinterErrors: true, // Allows reading error status
  fixLanguageMismatch: true, // Allows reading language status
);
```

### Reset Operations

#### Available Reset Methods
```dart
// Individual property resets
await readiness.resetConnection();
await readiness.resetMediaStatus();
await readiness.resetHeadStatus();
await readiness.resetPauseStatus();
await readiness.resetHostStatus();
await readiness.resetLanguageStatus();

// Complete reset
await readiness.resetAllStatuses();
```

#### Reset Usage Patterns
```dart
// ✅ CORRECT - External code can reset when needed
final readiness = PrinterReadiness(printer: printer);
await readiness.isPaused; // Initial read
await printer.unpause(); // External operation
await readiness.resetIsPaused(); // Force re-read
final newStatus = await readiness.isPaused; // Fresh value

// ❌ WRONG - Manager should not reset after fixes
// (Manager applies fixes but doesn't verify them)
```

### ReadinessResult Integration

#### Result Structure
```dart
final result = ReadinessResult.withReadyState(
  isReady, // Cached ready state
  readiness, // Lazy readiness object
  appliedFixes, // List of successful fixes
  failedFixes, // List of failed fixes
  fixErrors, // Error details
  totalTime, // Operation duration
);
```

#### Usage Patterns
```dart
// Get readiness with automatic corrections
final manager = PrinterReadinessManager(printer: printer);
final result = await manager.prepareForPrint(
  PrintFormat.zpl,
  ReadinessOptions(
    checkConnection: true,
    checkMedia: true,
    fixPausedPrinter: true,
    fixPrinterErrors: true,
  ),
);

if (result.success) {
  final readiness = result.data!;
  print('Ready: ${readiness.isReady}');
  print('Applied fixes: ${readiness.appliedFixes}');
}
```

### Hardware Communication Flow

#### 1. Initial Read (Lazy)
```dart
final readiness = PrinterReadiness(printer: printer, options: options);
// No hardware communication yet

final hasMedia = await readiness.hasMedia;
// Hardware communication happens here (if enabled in options)
// Result is cached for future access
```

#### 2. Manager Check (Uses Cache)
```dart
final manager = PrinterReadinessManager(printer: printer);
await manager.prepareForPrint(format, options);
// Manager accesses readiness properties
// Uses cached values, no additional hardware calls
```

#### 3. External Reset (When Needed)
```dart
// External code can reset and re-read when needed
await readiness.resetHasMedia();
final freshValue = await readiness.hasMedia; // New hardware read
```

### Best Practices

#### 1. Always Use Cached Values
```dart
// ✅ CORRECT
final readiness = PrinterReadiness(printer: printer);
final status1 = await readiness.mediaStatus;
final status2 = await readiness.mediaStatus; // Same cached value

// ❌ WRONG - Multiple hardware reads
final command1 = CommandFactory.createGetMediaStatusCommand(printer);
final command2 = CommandFactory.createGetMediaStatusCommand(printer);
```

#### 2. Respect Options
```dart
// Only read what's needed
final options = ReadinessOptions(
  checkConnection: true,
  checkMedia: false, // Don't read media
  checkHead: true,
);
```

#### 3. Use Reset Sparingly
```dart
// Only reset when you know the hardware state has changed
await printer.unpause();
await readiness.resetIsPaused(); // Justified reset

// Don't reset without reason
await readiness.resetAllStatuses(); // Usually unnecessary
```

#### 4. Manager Focus on Fixes
```dart
// Manager applies fixes but doesn't verify them
// Verification is the responsibility of the caller
final result = await manager.prepareForPrint(format, options);
if (result.data!.hasFixes) {
  // Caller can reset and verify if needed
  await result.data!.readiness.resetAllStatuses();
}
```

### Integration with Command System

#### Command Usage in Readiness
```dart
// Readiness uses commands for hardware communication
Future<void> _readMediaStatus() async {
  final command = CommandFactory.createGetMediaStatusCommand(_printer);
  final result = await command.execute();
  // Cache the result
}
```

#### Manager Uses Commands for Fixes
```dart
// Manager uses commands for corrections
if (options.fixPausedPrinter) {
  final unpauseCommand = CommandFactory.createSendUnpauseCommand(_printer);
  await unpauseCommand.execute();
}
```

### Performance Characteristics

#### Hardware Communication
- **Initial Read**: One command per enabled property
- **Subsequent Access**: No hardware communication (cached)
- **Manager Operations**: No additional hardware calls
- **Reset Operations**: One command per reset property

#### Memory Usage
- **Cached Values**: Minimal memory overhead
- **Readiness Object**: Lightweight, contains only status flags and cached values
- **Manager**: Stateless, no persistent data

#### Time Complexity
- **First Access**: O(1) per property (hardware read)
- **Cached Access**: O(1) (no hardware communication)
- **Manager Operations**: O(1) (uses cached values)
- **Reset Operations**: O(1) per property (single hardware read)

## 9. API Usage Guidelines

### Simple Operations
```dart
// Discover and connect
final printers = await Zebra.discoverPrinters();
await Zebra.connect(printers.first.address);

// Simple print
await Zebra.print('^XA^FO50,50^FDHello^FS^XZ');

// Disconnect
await Zebra.disconnect();
```

### Advanced Operations
```dart
// Smart print with event monitoring
final eventStream = Zebra.smartPrint(
  '^XA^FO50,50^FDHello^FS^XZ',
  maxAttempts: 3,
  timeout: Duration(seconds: 60),
);

eventStream.listen((event) {
  // Handle print events
});
```

### Stream-Based Discovery
```dart
// Real-time discovery
final deviceStream = await Zebra.discoverPrintersStream(
  timeout: Duration(seconds: 10),
  stopOnFirstPrinter: true,
);

deviceStream.listen((devices) {
  // Handle discovered devices
});
```

## 10. Architecture Principles

### 10.1 Lazy Initialization
- Managers are created only when needed
- Initialization happens automatically on first API call
- No explicit initialization required

### 10.2 Static API Design
- All operations are static methods for simplicity
- Consistent error handling with `Result<T>` pattern
- Stream-based operations for real-time updates

### 10.3 Manager Delegation
- Simple operations delegate to appropriate managers
- Complex workflows use specialized managers
- Direct manager access available for advanced use cases

### 10.4 Error Handling
- All operations return `Result<T>` for consistent error handling
- Smart print provides detailed error classification
- Automatic retry logic in smart print operations

### 10.5 Command Separation
- **Utility methods** in ZebraSGDCommands for data processing
- **Command strings** generated through CommandFactory
- **Command execution** handled by command classes
- **Never mix** utility and command generation

## 11. Circular Dependency Warning
- **Any import or reference from `ZebraPrinterManager` to `SmartPrintManager` is strictly forbidden.**
- If you need workflow logic, create a new `SmartPrintManager` in the consumer (UI, static API, etc.) and pass the manager as a dependency.
- This ensures a clean, maintainable, and testable architecture.

## 12. Example Usage

### Correct: UI or static API creates workflow manager
```dart
// Correct: UI or static API creates workflow manager
final manager = ZebraPrinterManager();
final smart = SmartPrintManager(manager);
final events = await smart.smartPrint(...);
```

### Forbidden: ZebraPrinterManager importing or referencing SmartPrintManager
```dart
// Forbidden: ZebraPrinterManager importing or referencing SmartPrintManager
// (This will break the architecture and is not allowed)
```

## 13. Summary Table
| Layer                | File                        | Depends On                | Exposes                |
|----------------------|-----------------------------|---------------------------|------------------------|
| Workflow/Orchestration | smart_print_manager.dart   | ZebraPrinterManager       | Events, workflow API   |
| State/Primitives     | zebra_printer_manager.dart  | ZebraPrinter              | Primitive ops, state   |
| Native Wrapper       | zebra_printer.dart          | (none)                    | Native ops only        |

## 14. File Structure Reference

- **[zebra.dart](mdc:lib/zebra.dart)**: Main static API entry point
- **[zebra_printer_manager.dart](mdc:lib/zebra_printer_manager.dart)**: Core printer management
- **[smart_print_manager.dart](mdc:lib/smart_print_manager.dart)**: Advanced print workflows
- **[zebra_printer_discovery.dart](mdc:lib/zebra_printer_discovery.dart)**: Device discovery
- **[zebra_printer.dart](mdc:lib/zebra_printer.dart)**: Low-level printer operations
- **[zebra_sgd_commands.dart](mdc:lib/zebra_sgd_commands.dart)**: Utility methods only (NO commands)
- **[command_factory.dart](mdc:lib/internal/commands/command_factory.dart)**: Command string generation
- **[internal/commands/](mdc:lib/internal/commands/)**: Individual command classes
- **[printer_readiness.dart](mdc:lib/models/printer_readiness.dart)**: Lazy status caching with single hardware read per property
- **[zebra_printer_readiness_manager.dart](mdc:lib/zebra_printer_readiness_manager.dart)**: Readiness orchestration and automatic corrections
- **[readiness_result.dart](mdc:lib/models/readiness_result.dart)**: Result structure for readiness operations

## 15. Best Practices

1. **Use Static API**: Prefer `Zebra.method()` over direct manager access
2. **Handle Results**: Always check `Result.success` before using data
3. **Use Smart Print**: Use `Zebra.smartPrint()` for production printing
4. **Monitor Events**: Listen to print event streams for real-time status
5. **Proper Cleanup**: Call `Zebra.dispose()` when done with the plugin
6. **Utility Only**: Use ZebraSGDCommands for data processing, not commands
7. **CommandFactory**: Generate all command strings through CommandFactory
8. **Command Classes**: Use specific command classes for operations
9. **Respect Dependencies**: Never violate the dependency direction rules
10. **Layer Separation**: Keep workflow logic separate from primitive operations

## 16. Common Patterns

### Connection Management
```dart
// Always check connection before printing
if (await Zebra.isConnected()) {
  await Zebra.print(data);
} else {
  await Zebra.connect(printerAddress);
  await Zebra.print(data);
}
```

### Error Handling
```dart
final result = await Zebra.connect(printerAddress);
if (result.success) {
  // Connection successful
} else {
  // Handle error: result.error?.message
}
```

### Stream Management
```dart
// Always cancel subscriptions
StreamSubscription? subscription;
subscription = Zebra.smartPrint(data).listen((event) {
  // Handle event
});

// Clean up
subscription?.cancel();
```

### Data Format Detection
```dart
// Use utility methods for format detection
if (ZebraSGDCommands.isZPLData(data)) {
  // Handle ZPL format
} else if (ZebraSGDCommands.isCPCLData(data)) {
  // Handle CPCL format
} else {
  // Handle unknown format
}
```

### Command Generation
```dart
// Use CommandFactory for command strings
final clearCommand = CommandFactory.createCommand(
  CommandType.sendClearAlerts,
  {},
);
await printer.sendCommand(clearCommand);
```

## 17. Enforcement
- **This rule is always applied.**
- **Any violation (circular reference, wrong dependency direction) must be fixed immediately.**
- **Review this rule after any significant codebase change.**

---

**See also:**
- [Command System Architecture](mdc:.cursor/rules/command-files.mdc)
- [Result-Based Architecture](mdc:.cursor/rules/result-based-architecture.mdc)
- [Event System](mdc:.cursor/rules/event-system.mdc)
- [Native Layer Responsibility Standards](mdc:.cursor/rules/native-layer-responsibility.mdc)
- [Platform-Specific Rules](mdc:.cursor/rules/ios/)
