# Command Pattern Standards

## Purpose
All printer operations are encapsulated as commands using the command pattern. Commands are created via [CommandFactory](mdc:lib/internal/commands/command_factory.dart) and follow strict architectural guidelines.

## Core Principles

### 1. One Command Per File
Each command class must be in its own file with a descriptive name:
```
lib/internal/commands/
├── send_zpl_clear_buffer_command.dart
├── send_cpcl_clear_buffer_command.dart
├── get_printer_status_command.dart
└── ...
```

### 2. Command Creation via Factory
❌ **WRONG**:
```dart
final command = SendZplClearBufferCommand(printer); // Direct instantiation
```

✅ **CORRECT**:
```dart
final command = CommandFactory.createSendZplClearBufferCommand(printer);
```

### 3. Command Naming Convention
Commands follow this pattern:
- **Action + Target + Command**: `SendZplClearBufferCommand`
- **Get + Property + Command**: `GetPrinterStatusCommand`
- **Send + Format + Action + Command**: `SendCpclFlushBufferCommand`

### 4. Format-Specific Commands
When operations differ by format, create separate commands:
```dart
// ZPL-specific
CommandFactory.createSendZplClearBufferCommand(printer)
CommandFactory.createSendZplClearErrorsCommand(printer)

// CPCL-specific
CommandFactory.createSendCpclClearBufferCommand(printer)
CommandFactory.createSendCpclClearErrorsCommand(printer)
```

### 5. No Generic Commands
Avoid generic commands that take settings as parameters. Instead, create specific commands:
```dart
// ❌ WRONG - Generic command
CommandFactory.createSetSettingCommand(printer, "device.pause", "false")

// ✅ CORRECT - Specific command
CommandFactory.createSendUnpauseCommand(printer)
```

### 6. Command Implementation Template
```dart
import '../../zebra_printer.dart';
import 'send_command_command.dart';

/// Command to [describe what it does]
class MySpecificCommand extends SendCommandCommand {
  MySpecificCommand(ZebraPrinter printer)
      : super(printer, 'actual command string');
      
  @override
  String get operationName => 'Descriptive Operation Name';
}
```

## CommandFactory Guidelines

### Adding New Commands
1. Create command class in its own file
2. Add factory method to CommandFactory:
```dart
static MySpecificCommand createMySpecificCommand(
  ZebraPrinter printer,
  [parameters...]
) => MySpecificCommand(printer, parameters...);
```
3. Add import to CommandFactory
4. Write unit test for the command

### Command Categories in Factory
- **Status Commands**: Getting printer information
- **Control Commands**: Clearing, pausing, mode switching
- **Settings Commands**: Getting/setting printer settings
- **Print Commands**: Sending print data

## Usage Examples

### Status Check
```dart
final command = CommandFactory.createGetPrinterStatusCommand(printer);
final result = await communicationPolicy.execute(
  () => command.execute(),
  command.operationName,
);
```

### Format-Specific Operation
```dart
// Automatically choose based on format
final command = format == PrintFormat.zpl
    ? CommandFactory.createSendZplClearBufferCommand(printer)
    : CommandFactory.createSendCpclClearBufferCommand(printer);
```

### Multiple Commands
```dart
final commands = [
  CommandFactory.createSendClearErrorsCommand(printer),
  CommandFactory.createSendClearBufferCommand(printer),
  CommandFactory.createSendUnpauseCommand(printer),
];

for (final command in commands) {
  await executeCommandWithAssurance(
    () => command.execute(),
    command.operationName,
  );
}
```

## Benefits
- **Encapsulation**: Commands encapsulate operation details
- **Testability**: Each command can be tested independently
- **Maintainability**: One command per file makes changes easy
- **Discoverability**: CommandFactory shows all available operations
 - **Type Safety**: Compile-time checking of command usage