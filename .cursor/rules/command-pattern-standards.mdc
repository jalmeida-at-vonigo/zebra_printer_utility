# Command Pattern Standards

## MANDATORY: Use CommandFactory for ALL Command Creation

**CRITICAL RULE**: Commands must NEVER be instantiated directly outside of the CommandFactory and test files.

### ✅ CORRECT - Use CommandFactory
```dart
// Always use CommandFactory.create* methods
final command = CommandFactory.createGetMediaStatusCommand(printer);
final result = await command.execute();

// Or inline
final result = await CommandFactory.createSendUnpauseCommand(printer).execute();
```

### ❌ FORBIDDEN - Direct Command Instantiation
```dart
// NEVER do this in production code
final command = SendZplClearBufferCommand(printer); // Direct instantiation
final command = GetMediaStatusCommand(printer);     // Direct instantiation
final command = new SendUnpauseCommand(printer);    // Direct instantiation
```

## Command Factory Location
- **CommandFactory**: [lib/internal/commands/command_factory.dart](mdc:lib/internal/commands/command_factory.dart)
- **Import**: `import 'internal/commands/command_factory.dart';`

## Enforcement Rules

### 1. Production Code Requirements
- **MUST** import only `command_factory.dart` for command creation
- **MUST NOT** import individual command classes (e.g., `send_unpause_command.dart`)
- **MUST NOT** use direct command instantiation (`new` or constructor calls)

### 2. Allowed Direct Instantiation
- **Test files only**: Direct instantiation is allowed in `test/**/*.dart` files
- **Command classes themselves**: For inheritance (e.g., `extends PrinterCommand`)
- **CommandFactory class**: For creating instances to return

### 3. Code Review Checklist
- [ ] No direct command imports outside of commands folder and tests
- [ ] All command creation uses `CommandFactory.create*` methods
- [ ] No `new CommandName()` or `CommandName()` calls in production code
- [ ] CommandFactory is imported where commands are needed

## Available Factory Methods
All command creation should use these methods from [CommandFactory](mdc:lib/internal/commands/command_factory.dart):

```dart
// Status Commands
CommandFactory.createGetMediaStatusCommand(printer)
CommandFactory.createGetHeadStatusCommand(printer)
CommandFactory.createGetPauseStatusCommand(printer)
CommandFactory.createGetLanguageCommand(printer)
CommandFactory.createGetPrinterStatusCommand(printer)
CommandFactory.createGetDetailedPrinterStatusCommand(printer)

// Action Commands
CommandFactory.createSendUnpauseCommand(printer)
CommandFactory.createSendCalibrationCommand(printer)
CommandFactory.createSendClearErrorsCommand(printer)
CommandFactory.createSendClearBufferCommand(printer)
CommandFactory.createSendFlushBufferCommand(printer)

// Format-Specific Commands
CommandFactory.createSendZplClearErrorsCommand(printer)
CommandFactory.createSendCpclClearErrorsCommand(printer)
CommandFactory.createSendZplClearBufferCommand(printer)
CommandFactory.createSendCpclClearBufferCommand(printer)
CommandFactory.createSendZplFlushBufferCommand(printer)
CommandFactory.createSendCpclFlushBufferCommand(printer)
CommandFactory.createSendSetZplModeCommand(printer)
CommandFactory.createSendSetCpclModeCommand(printer)

// Generic Commands
CommandFactory.createGetSettingCommand(printer, setting)
CommandFactory.createSendCommandCommand(printer, command)
CommandFactory.createCheckConnectionCommand(printer)
```

## Architecture Benefits
- **Centralized Creation**: All command instantiation in one place
- **Easier Testing**: Mock the factory instead of individual commands
- **Consistent Interface**: Uniform creation patterns
- **Future Flexibility**: Easy to add logging, caching, or validation
- **Dependency Injection**: Can inject different implementations

## Violation Examples to Avoid
```dart
// ❌ Don't import individual commands
import 'internal/commands/send_unpause_command.dart';

// ❌ Don't instantiate directly
final cmd = SendUnpauseCommand(printer);

// ❌ Don't use new keyword
final cmd = new GetMediaStatusCommand(printer);
```

## Integration with Communication Policy
Always use CommandFactory with [CommunicationPolicy](mdc:lib/internal/communication_policy.dart):

```dart
final result = await _communicationPolicy.execute(
  () => CommandFactory.createSendUnpauseCommand(printer).execute(),
);
```

This pattern ensures proper error handling, retries, and logging through the communication policy.